<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8">
<title>Mini Tetris JS</title>
<style>
body{
  background:#111;
  color:white;
  display:flex;
  justify-content:center;
  align-items:center;
  height:100vh;
  font-family:Arial;
}
.game{
  display:flex;
  gap:20px;
}
canvas{
  background:black;
  border:2px solid white;
}
button{
  margin:4px;
  padding:6px 10px;
}
</style>
</head>
<body>

<div class="game">
  <canvas id="tetris" width="300" height="600"></canvas>

  <div>
    <h2>Mini Tetris</h2>
    <p>Score: <span id="score">0</span></p>
    <p>High Score: <span id="high">0</span></p>

    <h3>Next</h3>
    <canvas id="next" width="120" height="120"></canvas>

    <button onclick="togglePause()">Pause</button>
    <button onclick="restart()">Restart</button>

    <p>⬅️ ➡️ Move</p>
    <p>⬆️ Rotate</p>
    <p>⬇️ Drop</p>
  </div>
</div>

<script>
/* =================================================
   SETUP CANVAS
================================================= */
const canvas = document.getElementById("tetris");
const ctx = canvas.getContext("2d");
const nextCanvas = document.getElementById("next");
const nextCtx = nextCanvas.getContext("2d");

const BLOCK = 30;
ctx.scale(BLOCK, BLOCK);
nextCtx.scale(30, 30);

/* =================================================
   GAME CONSTANT
================================================= */
const COLS = 10;
const ROWS = 20;

const COLORS = [
  null,
  "cyan",
  "blue",
  "orange",
  "yellow",
  "green",
  "purple",
  "red"
];

const SHAPES = [
  [[1,1,1,1]],                 // I
  [[2,0,0],[2,2,2]],           // J
  [[0,0,3],[3,3,3]],           // L
  [[4,4],[4,4]],               // O
  [[0,5,5],[5,5,0]],           // S
  [[0,6,0],[6,6,6]],           // T
  [[7,7,0],[0,7,7]]            // Z
];

/* =================================================
   DOM ELEMENT
================================================= */
const scoreEl = document.getElementById("score");
const highEl  = document.getElementById("high");

/* =================================================
   GAME STATE (URUT & AMAN)
================================================= */
let board = createBoard();

let score = 0;
let highScore = localStorage.getItem("tetrisHigh") || 0;

scoreEl.textContent = score;
highEl.textContent  = highScore;

let dropInterval = 1000;
let dropCounter = 0;
let lastTime = 0;
let paused = false;

let piece = createPiece();
let nextPiece = createPiece();

/* =================================================
   FUNCTIONS
================================================= */
function createBoard(){
  return Array.from({length:ROWS}, () => Array(COLS).fill(0));
}

function createPiece(){
  const shape = SHAPES[Math.floor(Math.random()*SHAPES.length)];
  return {
    shape,
    x: Math.floor(COLS/2) - Math.floor(shape[0].length/2),
    y: 0
  };
}

function drawCell(x,y,v){
  ctx.fillStyle = COLORS[v];
  ctx.fillRect(x,y,1,1);
  ctx.strokeStyle = "#000";
  ctx.strokeRect(x,y,1,1);
}

function drawBoard(){
  board.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if(v) drawCell(x,y,v);
    });
  });
}

function drawPiece(p){
  p.shape.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if(v) drawCell(p.x+x,p.y+y,v);
    });
  });
}

function drawNext(){
  nextCtx.clearRect(0,0,4,4);
  nextPiece.shape.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if(v){
        nextCtx.fillStyle = COLORS[v];
        nextCtx.fillRect(x,y,1,1);
        nextCtx.strokeRect(x,y,1,1);
      }
    });
  });
}

function collide(p){
  return p.shape.some((row,y)=>{
    return row.some((v,x)=>{
      if(v){
        const nx = p.x + x;
        const ny = p.y + y;
        return (
          nx < 0 ||
          nx >= COLS ||
          ny >= ROWS ||
          (board[ny] && board[ny][nx])
        );
      }
    });
  });
}

function merge(){
  piece.shape.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if(v) board[piece.y+y][piece.x+x] = v;
    });
  });
}

function clearLines(){
  let lines = 0;
  for(let y=ROWS-1;y>=0;y--){
    if(board[y].every(v=>v!==0)){
      board.splice(y,1);
      board.unshift(Array(COLS).fill(0));
      lines++;
      y++;
    }
  }
  if(lines){
    score += lines * 10;
    scoreEl.textContent = score;
    dropInterval = Math.max(200, dropInterval - 50);
  }
}

function rotate(){
  const rotated = piece.shape[0].map((_,i)=>
    piece.shape.map(r=>r[i]).reverse()
  );
  const old = piece.shape;
  piece.shape = rotated;
  if(collide(piece)) piece.shape = old;
}

function drop(){
  piece.y++;
  if(collide(piece)){
    piece.y--;
    merge();
    clearLines();
    piece = nextPiece;
    nextPiece = createPiece();
    drawNext();

    if(collide(piece)){
      gameOver();
    }
  }
  dropCounter = 0;
}

function togglePause(){
  paused = !paused;
}

function restart(){
  board = createBoard();
  score = 0;
  dropInterval = 1000;
  scoreEl.textContent = score;
  piece = createPiece();
  nextPiece = createPiece();
  paused = false;
}

function gameOver(){
  if(score > highScore){
    highScore = score;
    localStorage.setItem("tetrisHigh", highScore);
    highEl.textContent = highScore;
  }
  alert("GAME OVER\nScore: " + score);
  restart();
}

/* =================================================
   GAME LOOP
================================================= */
function update(time=0){
  if(paused){
    requestAnimationFrame(update);
    return;
  }

  const delta = time - lastTime;
  lastTime = time;
  dropCounter += delta;

  if(dropCounter > dropInterval){
    drop();
  }

  ctx.clearRect(0,0,COLS,ROWS);
  drawBoard();
  drawPiece(piece);

  requestAnimationFrame(update);
}

drawNext();
update();

/* =================================================
   CONTROL
================================================= */
document.addEventListener("keydown", e=>{
  if(e.key==="ArrowLeft"){
    piece.x--;
    if(collide(piece)) piece.x++;
  }
  if(e.key==="ArrowRight"){
    piece.x++;
    if(collide(piece)) piece.x--;
  }
  if(e.key==="ArrowDown"){
    drop();
  }
  if(e.key==="ArrowUp"){
    rotate();
  }
  if(e.key==="p"){
    togglePause();
  }
});
</script>

</body>
</html>
